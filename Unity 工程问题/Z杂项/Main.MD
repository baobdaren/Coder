# Unity面试题目闲谈😄

## `什么是协同程序`

unity的携程其实是每一帧结束后去检查yield条件。协程不是多线程。

## `值类型和引用类型`

值类型一般分配在栈上，作为引用类型的成员时则跟随引用类型。
引用类型分配在堆上。  
在传递时，按值传递。值类型则复制新的值，引用类型则复制了一个引用（指针）。  
值类型创建时直接开辟所需内存，引用类型创建时先创建一个引用，new一个实例时才在堆上开辟对象所需内存。  
`classObj = null`意味着指向堆上对象的指针指向新的对象，原来的对象还存在。

## `string和stringbuilder`

string在重新修改（比如+='a'）后会重新产生新的对象。string是不可变引用类型。stringbuilder则可以在一开始就设定容量。防止大量的拼接操作带来的性能问题。

## `类，接口，抽象类`  

接口的主要作用是实现多态。
接口相对于类：

1. 不能包含有实现的方法和字段
2. 成员都为public
3. 继承接口的类必须实现所有方法
4. 接口不能被实例化
5. 接口可以继承多个接口

抽象类  
抽象类主要：  

1. 抽象类可以包含普通方法，也可以包含抽象方法，抽象方法没有实现。
2. 抽象类只能继承一个普通类或抽象类，可以继承多个接口。
3. 抽象方法只能放在抽象类，抽象类不能被实例化。
4. 如果子类不是抽象类，则必须实现抽象方法。

## `const和readOnly`

const和readonly都声明一个变量为常量

1. const修饰的变量是static的，只能通过类名访问。
2. const修饰的变量必须在声明时赋值，readonly则还可以在构造函数或静态构造函数中赋值。
3. const在编译时就确定了，readonly则在运行才赋值。
4. const定义除字符串之外的引用类型时，只能赋值为null。

## `数据类型强制转换`

如下代码  

```cs
short i1 = 1;
i1 = i1 + 1; //1 为int类型 i1+1中i1被强制为int类型，但是i1+1结果为int，所以这里赋值时可能会出现精度丢失
i1 += 1; //这里不会出错

short i2 = 1;
short i3 = i1 + i2;//这里可能结果大于了short类型最大数，所以需要强转int
```

## `一个对象从唤醒到销毁的声明周期`

Awake-onEnable-Start-Update-FixedUpdate-LateUpdate-onDisable-onDestroy


