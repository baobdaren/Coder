# Lua和C#交互原理

## 它们时如何调用的

C#和Lua的交互，主要是通过C语言来交互。  

之所以要用C语言，是因为Lua是C语言写的。但是Lua和C语言之间有很多不同，C语言内存释放需要显示调用free函数，而Lua是通过GC机制；而且C语言是静态语言，即运行时类型已经确定，而Lua是动态的，编译时类型无法确定。从而引入虚拟栈。

基本原理是通过虚拟栈，调用方给虚拟栈压入数据或请求，被调用方则去从虚拟栈中读取这些信息。被调用放处理完完后，则把返回的数据重新压入栈。之后调用则从栈中取出返回值

<!-- * C#调用Lua：C#先调用Lua解析器底层dll（C语言 lua接口库），再由dll去执行Lua文件。
* `Lua调用C#`：Warp方式，首先生成C#源文件对应的Warp文件。开始时由Lua调用Warp文件，再由Warp文件调用C#。也就是通过中间代码（或者使用反射，但是效率低）

C#对象和Lua对象表示方法不同，所以最好保存反复使用对象。

从内存方面说：C#和Lua交互主要依靠虚拟栈。比如C#调用Lua：C#首先把请求或数据放到栈顶，Lua则从栈顶去取，处理完成后把结果放回栈顶，最后C#则再从栈顶取出lua处理完的数据，完成交互。 -->

## Lua和C#互相调用需要注意什么

lua中引用C#object，代价昂贵  
Lua使用一个C#对象后，在C#中会保存在一个Dictionary中，防止GC。  
Lua使用一个没有使用过的对象时，需要很复杂的操作去获取，然后会保存在上述字典。Lua方释放掉后，会被删除。  
Lua每使用一次这个对象或者调用其方法都会去字典里通过ID查找这个对象。  
`gameobject.tranform`：这段代码获取到transform只是临时返回一下。

在Lua和C#之间传递unity独有的类型（Vector3），代价更加昂贵
直接在函数中传递三个float比传递vector3要快

Lua和C#之间传递类型建议
由于lua和C和C#之间内存分配策略以及类型的表示不同，因此他们之间的参数传递需要进行转换（术语parameter mashalling），不同类型消耗不同。
最差：Vector3等unity独有类型  
其次：bool，string，各种object  
最好：int，float，double  

bool和string根据微软官方文档，他们的实现和C语言不同，这意味着从C到C#传递他们需要类型转换。  
非常严重的还有数组，因为Lua中没有数组，只有Table。所以需要逐个复制，如果是对象，还需要转换。

频繁调用的函数，参数个数要控制。  

优先使用static函数，可以减少访问对象耗时

注意，lua拿着C#对象的引用会导致C#对象无法释放。

考虑Lua中自己管理id，而不是直接引用C#的Object
自行分配id去索引对象，传参也传递id  

合理利用out关键字返回参数  
比如返回一个vector3时，转换成返回三个float性能更好  
`getPos(out x, out y, out z)`
